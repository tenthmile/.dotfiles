#+TITLE: My Emacs configuration

* Configuration
This is my Emacs configuration its structure is based upon [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Emacs configuration]].
However I use the packages I like.

"use-package" will install the packages automatically (due to the code in [[Loading installed packages]]).

When it comes to configuring, we can easily edit those coding areas by entering it and pressing C-c '
You can also run the code if your in the editing mode by running =M-x eval-buffer=
The =:tangle yes= flag on every source code block is responsible for exporting to a =.el= file.
However non tangled source will still be executed.

** Packages

*** Adding package sources					 :firstSetup:

Use =M-x package-refresh-contents= to reload the list of packages after adding these for the first time.
#+BEGIN_SRC emacs-lisp :tangle yes
    (require 'package)
    (unless (assoc-default "melpa" package-archives)
      ;;(add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/") t)
      (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
      (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
      ;;(package-refresh-contents) ;; can be commented out after first run.
    )
#+END_SRC

*** Enable downloading and installing of packages
The "use-package" package is capable of installing other packages and will be used throughout this configuration file.
It's also capable of speeding up loading times.
#+BEGIN_SRC emacs-lisp :tangle yes
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  (setq use-package-verbose t)
  (setq use-package-always-ensure t) ;; this causes use-package to always install packages if not existent
  (require 'use-package)
  (use-package auto-compile
    :config (auto-compile-on-load-mode))
  (setq load-prefer-newer t)
#+END_SRC

** General configuration
*** Libraries
Loading packages I like to program with.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dash)
#+END_SRC

*** Backups
This is one of the things people usually want to change right away. By default, Emacs saves backup files in the current directory. These are the files ending in =~= that are cluttering up your directory lists. The following code stashes them all in =~/.emacs.d/backups=, where I can find them with =C-x C-f= (=find-file=) if I really need to.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC

*** History							    :rethink:
Emacs is capable of storing your history of "last used commands, searches, clipboard".
However I'm not sure if I want it active.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;(setq savehist-file "~/.emacs.d/savehist")
  ;;(savehist-mode 1) ;; rethink if i want to use this
  ;;(setq history-length t)
  ;;(setq history-delete-duplicates t)
  ;;(setq savehist-save-minibuffer-history 1)
  ;;(setq savehist-additional-variables
  ;;      '(kill-ring
  ;;        search-ring
  ;;        regexp-search-ring))
#+END_SRC

*** Sentences end with a single space

In my world, sentences end with a single space. This makes sentence navigation (=M-a= and =M-e=) commands work for me.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq sentence-end-double-space nil)
#+END_SRC

*** Marked text will be overridden
Many modern text editors override marked text. Emacs doesn't do so in the standard configuration.
#+BEGIN_SRC emacs-lisp :tangle yes
  (delete-selection-mode 1)
#+END_SRC

*** Helm - interactive completion
Helm is one of the best tool for navigating and listing options.
It makes searching for commands more easy due to a search that is not dependent on the order of the words entered.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helm
    :diminish helm-mode
    :init
    (progn
      (require 'helm-config)
      (setq helm-candidate-number-limit 100)
      ;; From https://gist.github.com/antifuchs/9238468
      (setq helm-idle-delay 0.0 ; update fast sources immediately (doesn't).
            helm-input-idle-delay 0.01  ; this actually updates things
                                          ; reeeelatively quickly.
            helm-yas-display-key-on-candidate t
            helm-quick-update t
            helm-M-x-requires-pattern nil
            helm-ff-skip-boring-files t)
      (helm-mode))
    :bind (("C-x C-f" . helm-find-files)
           ;;("C-c h" . helm-mini)  ;; overriden by Hide-Show
           ("C-h a" . helm-apropos)
           ("C-x C-b" . helm-buffers-list)
           ("C-x b" . helm-buffers-list)
           ("M-y" . helm-show-kill-ring)
           ("M-x" . helm-M-x)
           ("C-x c o" . helm-occur)
           ;;("C-x c s" . helm-swoop)
           ;;("C-x c y" . helm-yas-complete)
           ;;("C-x c Y" . helm-yas-create-snippet-on-region)
           ;;("C-x c b" . my/helm-do-grep-book-notes)
           ;;("C-x c SPC" . helm-all-mark-rings)
           ))
#+END_SRC

Great for describing bindings. I'll replace the binding for =where-is= too.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helm-descbinds
    :defer t
    :bind (("C-h b" . helm-descbinds)
           ("C-h w" . helm-descbinds)))
#+END_SRC

*** TODO Clipboard						    :improve:
Emacs Clipboard Management used to be messy.
Now it is less.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq x-select-enable-primary nil) ; Emacs commands C-w and C-y should NOT use the primary selection. or else C-Space will copy stuff
  (setq x-select-enable-clipboard t) ; Emacs commands C-w and C-y now use the clipboard selection.
#+END_SRC

Find a way to get primary selection into Emacs.

*** Change "yes or no" to "y or n"
Lazy people like me never want to type "yes" when "y" will suffice.

#+BEGIN_SRC emacs-lisp :tangle yes
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Indent with Space
Some people call tabs evil because it breaks alignment with variable tab with.
Also many programming languages or projects prefer spaces.
That's why I disable tab indention and use spaces.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default indent-tabs-mode nil)
#+END_SRC
*** Mouse Scrolling
 I don't like the smooth scrolling packages available on Emacs, as they slow down =C-v= and =M-v=.
 However I dislike the jumping. Therefore we only modify the mouse wheel scrolling.

 #+BEGIN_SRC emacs-lisp :tangle yes
   (setq scroll-conservatively 101) ;; move minimum when cursor exits view, instead of recentering
   (setq mouse-wheel-scroll-amount '(1)) ;; mouse scroll moves 1 line at a time, instead of 5 lines
   (setq mouse-wheel-progressive-speed nil) ;; on a long mouse scroll keep scrolling by 1 line
   (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
 #+END_SRC
 What really would make me happy though would be Pixel-based mouse wheel smooth scroll like the Emacs Mac port has.

*** Help - guide-key
The package =guide-key= shows an popup after commonly used Command Prefixes to assist finding the correct action.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package guide-key
;;    :defer t
    :diminish guide-key-mode
    :config
    (progn
      ;;(setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c")) ;; enable for specific prefixes
      (setq guide-key/guide-key-sequence t) ;; enable for all prefixes
      (guide-key-mode 1)))  ;; Enable guide-key-mode
#+END_SRC

*** UTF-8 							    :clarify:
Currently not sure what this does.

#+BEGIN_SRC emacs-lisp :tangle yes
  (prefer-coding-system 'utf-8)
  (when (display-graphic-p)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+END_SRC

** Visual Stuff
*** Mode line format
Display a more compact mode line.
=use package= has the =:diminish= keyword. It causes some minor mode to not show up in the mode line listings.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package smart-mode-line)
#+END_SRC
*** Wrap long lines
Visual line mode is a minor mode that wraps lines that are longer then the window.
This minor mode also modifies commands like =C-a=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key (kbd "<f9>") 'visual-line-mode)
#+END_SRC
*** Remove Toolbar
#+BEGIN_SRC emacs-lisp :tangle yes
  (tool-bar-mode -1)
#+END_SRC

*** Startup Screen
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq inhibit-startup-message t)
  (setq initial-scratch-message ";; This buffer is for temporary notes and for Lisp evaluation.
")
#+END_SRC

*** Cursor
First we make the cursor small and not blocky.
#+BEGIN_SRC emacs-lisp :tangle yes
  (set-default 'cursor-type 'bar)
#+END_SRC

Then we make the cursor blink in a variable manner (longer on then off).
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; cursor blink intervall
  (defvar blink-cursor-interval-visible 1.5)
  (defvar blink-cursor-interval-invisible 0.5)

  (defadvice internal-show-cursor (before unsymmetric-blink-cursor-interval)
    "Make the cursor blink longer visible then inviseble."
    (when blink-cursor-timer
      (setf (timer--repeat-delay blink-cursor-timer)
            (if (internal-show-cursor-p)
                blink-cursor-interval-visible
              blink-cursor-interval-invisible))))
  (ad-activate 'internal-show-cursor)
#+END_SRC

Atlast we want the cursor line to be highlighted
#+BEGIN_SRC emacs-lisp :tangle yes
    (global-hl-line-mode 1)
    (make-variable-buffer-local 'global-hl-line-mode)
#+END_SRC

I use [[https://ogbe.net/emacsconfig.html][Dennis' Emacs configuration theme]] for the /cursor/ and /line highlight/ however I modify it's apperance based on terminal/gui.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun dennis-set-cursor ()
    "Manages the cursor boldness in read only texts as well as the color."
    ;; (set-cursor-color "gold") ;; set cursor color to gold (dark)
    (set-cursor-color "#75B000") ;; set cursor color to green-ish color (bright)
    (set-face-attribute 'region nil :background "orange" :foreground "black")
    (if (display-graphic-p)
        (progn
          (set-face-attribute 'helm-selection nil :background "gray80")
          (set-face-background 'hl-line "gray80"))
      (progn
        (set-face-attribute 'helm-selection nil :background "color-235")
        (set-face-background 'hl-line "color-235")))
    (set-face-foreground 'highlight nil)
    (set-face-underline 'hl-line nil)
    (cond
     (buffer-read-only
      (setq cursor-type 'box))
     (t
      (setq cursor-type 'bar)))
    ;; red cursor for overwrite mode
    (when overwrite-mode
      (set-cursor-color "red")))
  (dennis-set-cursor)
#+END_SRC

This needs to run after every command, since some modes screw with the cursor.
#+BEGIN_SRC emacs-lisp :tangle yes
  (add-hook 'post-command-hook 'dennis-set-cursor)
#+END_SRC

*** Theme

I like the =sanityinc-tomorrow-day= for a bright Emacs.
#+Begin_SRC emacs-lisp :tangle yes
  (use-package color-theme-sanityinc-tomorrow)
#+END_SRC
A dark theme I like is =wombat= however I currently don't have it installed.

**** Font and Font-Size						 :firstSetup:
I found a nice looking programmers font.
It's called Source Code Pro and can be found in the Arch Linux Repository =adobe-source-code-pro-fonts=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/setup-font-for-theme ()
    (interactive)
    (let ()
      (set-face-attribute 'default nil :family "Source Code Pro")
      ;; increasing font size
      (set-face-attribute 'default nil :height 100)
      (set-fontset-font "fontset-default" '(#x1F300 . #x1F5FF) "EmojiOne Color")
      (set-fontset-font "fontset-default" '(#x1F600 . #x1F64F) "EmojiOne Color")))
#+END_SRC

**** Powerline
Powerline is a mode line for Emacs. And it has really cool themes that come with it.
Using [[https://ogbe.net/emacsconfig.html][Dennis' Emacs configuration theme]] we get a really nice look.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/powerline-theme ()
    (interactive)
    (if (display-graphic-p)
        (progn
          (setq powerline-default-separator 'arrow)
          (setq powerline-default-separator-dir '(left . right)) ;; default
          (powerline-default-theme))
      (setq powerline-default-separator-dir '(right . left))))

  (use-package powerline
    :config
    (my/powerline-theme))
#+END_SRC

**** TODO Linum Highlight					    :rethink:
;; linum highlight
(require 'linum)
(set-face-attribute 'linum nil
                    :background (face-attribute 'default :background)
                    ;;:foreground (face-attribute 'font-lock-comment-face :foreground)
		    )
(defface linum-current-line-face
  ;;`((t :background "gray30" :foreground "gold"))
  `((t :background "gray80" :foreground "blue")) ;; bright
  "Face for the currently active Line number")
(defvar my-linum-current-line-number 0)
(setq my-linum-format-string " %d ")
(defun my-linum-format (line-number)
  (propertize (format my-linum-format-string line-number) 'face
              (if (eq line-number my-linum-current-line-number)
                  'linum-current-line-face
                'linum)))
(setq linum-format 'my-linum-format)
(defadvice linum-update (around my-linum-update)
  (let ((my-linum-current-line-number (line-number-at-pos)))
    ad-do-it))
(ad-activate 'linum-update)

**** Applying theme
Now we apply the theme. The function is so complicated due to bugs with the emacsclient not always reapplying the theme. ([[Emacs server Themes]])

The theme I like it has some flaws, like having hard to read yellow text on white backgrounds.
Therefore we run a function after the application of the theme to apply my patches.

All in all it looks like this:
#+BEGIN_SRC emacs-lisp :tangle yes
    (defvar my:theme 'sanityinc-tomorrow-day)
    ;;(defvar my:theme-terminal 'tango)
    (defvar my:theme-window-loaded nil)
    (defvar my:theme-terminal-loaded nil)

    (defun my/setup-color-theme-fixes ()
      (interactive)
      (if (display-graphic-p)
          (progn
            ;; make program source code readable again (on white background)
            (set-face-attribute 'font-lock-function-name-face nil :foreground "#f5871f" :weight 'bold)
            (set-face-attribute 'font-lock-variable-name-face nil :foreground "DarkGoldenrod3" :weight 'bold)
            ;; make outline/orgmode color readable again (on white background)
            (set-face-attribute 'outline-4 nil :foreground "magenta")
            ;; bar seperating line numbers and text
            (set-face-attribute 'fringe nil :background "#F0F0F0")
            ;; org-mode agenda tasks that start today should not be green (like finished tasks)
            (set-face-attribute 'org-scheduled-today nil :foreground "black" :weight 'semi-bold)
            (set-face-attribute 'org-scheduled nil :foreground "black")
            ;; call font settings
            (my/setup-font-for-theme))
        ))

    (if (daemonp)
        (add-hook 'after-make-frame-functions
                  (lambda (frame)
                    (select-frame frame)
                    (if (window-system frame)
                        ;; GUI theme
                        (progn
                          (if my:theme-window-loaded
                              (enable-theme my:theme)
                            (load-theme my:theme t))
                          (setq my:theme-window-loaded t)
                          ;; fixes theme
                          (my/setup-color-theme-fixes)
                          (blink-cursor-mode 1)
                          (dennis-set-cursor)
                          (my/powerline-theme))
                      ;; terminal theme
                      ;;(if my:theme-terminal-loaded
                      ;;    (enable-theme my:theme-terminal)
                      ;;  (load-theme my:theme-terminal))
                      (setq my:theme-terminal-loaded t)
                      ;; fixes theme
                      (my/setup-color-theme-fixes)
                      (my/powerline-theme))))

      (if (display-graphic-p)
          (when (boundp 'my:theme)
            (setq my:theme-window-loaded t)
            (load-theme my:theme t)
            (my/setup-color-theme-fixes))
        (when (boundp 'my:theme-terminal)
          (setq my:theme-terminal-loaded t)
          (load-theme my:theme-terminal t)
          (my/setup-color-theme-fixes))))
#+END_SRC

*** Line numbering
I do like my line numbers even though it makes large files slow (when using =linum=, hopefully =nlinum= fixes this).
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package nlinum
    :config
    (global-nlinum-mode 1))
  (column-number-mode 1)
#+END_SRC

I use =nlinum= as it tries to be more efficient than =linum=.

*** Prettify Symbol
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default prettify-symbols-unprettify-at-point 'right-edge)
  (global-prettify-symbols-mode t)
#+END_SRC
*** TODO Highlight Text (marking text for presentations/students)
** Frame-Title Format
Since Emacs leaks my username to potential recordings/streams (I don't want that), we have to rename the Emacs GUI title.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq frame-title-format '("%b"))
#+END_SRC
** Navigation

*** Pop to mark
Handy way of getting back to previous places.
It's easier than using =C-u C-<SPC>=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (bind-key "C-x p" 'pop-to-mark-command)
  (setq set-mark-command-repeat-pop t)
#+END_SRC
=(setq set-mark-command-repeat-pop t)= makes =C-u C-SPC= repeatable.
e.g. =C-u C-SPC C-SPC= pop the mark twice. This does not apply to =C-x p=.

*** Move to beginning of line (smartly)
Copied from http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/
This moves the cursor to the first non white-space character (unless we are already there).
This keybinding =C-a= can be overridden by other major-/minor-modes (e.g. org-mode).

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

  ;; remap C-a to `smarter-move-beginning-of-line'
  (global-set-key [remap move-beginning-of-line]
                  'my/smarter-move-beginning-of-line)
#+END_SRC

*** Copy filename to clipboard
This is a function we can call to copy the file name to the clipboard.
It saves us some keystrokes like opening Dired =C-x C-j= and copying the folder and file name.
http://emacsredux.com/blog/2013/03/27/copy-filename-to-the-clipboard/ https://github.com/bbatsov/prelude
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun prelude-copy-file-name-to-clipboard ()
    "Copy the current buffer file name to the clipboard."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (kill-new filename)
        (message "Copied buffer file name '%s' to the clipboard." filename))))

#+END_SRC

*** Print filename as message
This is a function prints the current file path as a message.
That way one can orientate him/herself when jumping through a projects with tags.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/show-file-name ()
    "Prints the current buffer file name as a message."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (message "%s" filename))))

  (bind-key "C-c ?" 'my/show-file-name)
#+END_SRC

*** Dired
Dired is the Emacs file browser. It is capable of renaming files =C-x C-q= (=wdired-change-to-wdired-mode=).
You can create new folders with =+=.
You can rename them with =R=.
And delete them with =D=.

You can even do actions on multiple files.
Press =d= to prepare mass deletion.
Mark and unmark them with =m= and =u= respectively.

Files can also be feed to any console command by pressing =!= or asynchronous =&=.

**** Hiding hidden files

However it is filled with a lot of junk. Therefore we might want to hide it.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dired+
    :config (setq-default dired-omit-files "^\\.[^\\.].+\\|^#.+#$\\|.+~$")
    :bind (:map dired-mode-map
           ("M-." . dired-omit-mode)))
#+END_SRC

**** Open with GUI programs
While Emacs is capable of editing many files, it is lacking in other departments.
If we want to edit a file with it's usually associated program or browse with the default file browsed, we use the following functions.

This is from http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun xah-open-in-external-app ()
    "Open the current file or dired marked files in external app.
  The app is chosen from your OS's preference.
  Version 2015-01-26
  URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'"
    (interactive)
    (let* (
           (ξfile-list
            (if (string-equal major-mode "dired-mode")
                (dired-get-marked-files)
              (list (buffer-file-name))))
           (ξdo-it-p (if (<= (length ξfile-list) 5)
                         t
                       (y-or-n-p "Open more than 5 files? "))))

      (when ξdo-it-p
        (cond
         ((string-equal system-type "windows-nt")
          (mapc
           (lambda (fPath)
             (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t))) ξfile-list))
         ((string-equal system-type "darwin")
          (mapc
           (lambda (fPath) (shell-command (format "open \"%s\"" fPath)))  ξfile-list))
         ((string-equal system-type "gnu/linux")
          (mapc
           (lambda (fPath) (let ((process-connection-type nil)) (start-process "" nil "xdg-open" fPath))) ξfile-list))))))

  (defun xah-open-in-desktop ()
    "Show current file in desktop (OS's file manager)."
    (interactive)
    (cond
     ((string-equal system-type "windows-nt")
      (w32-shell-execute "explore" (replace-regexp-in-string "/" "\\" default-directory t t)))
     ((string-equal system-type "darwin") (shell-command "open ."))
     ((string-equal system-type "gnu/linux")
      (let ((process-connection-type nil)) (start-process "" nil "xdg-open" "."))
      ;; (shell-command "xdg-open .") ;; 2013-02-10 this sometimes froze emacs till the folder is closed. ⁖ with nautilus
      ) ))

  (eval-after-load 'dired '(define-key dired-mode-map (kbd "e") 'xah-open-in-external-app))
  (eval-after-load 'dired '(define-key dired-mode-map (kbd "C-d") 'xah-open-in-desktop))
#+END_SRC

*** avy, ace-window and other
Quickly jump to a position in view.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package avy
    :bind
    (("C-;" . avy-goto-char)
     ("C-:" . avy-goto-word-or-subword-1)
     ("M-g m" . avy-move-line)
     ("M-g l" . avy-goto-line)))
#+END_SRC

=ace-window= overrides the default window switching behaviour. If three or more windows exist, the change window command will ask for a number to jump to.
When prefixed with one /universal-argument/, instead of switching to selected window, the selected window is swapped with current one.
When prefixed with two /universal-argument/, the selected window is deleted instead.
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (use-package ace-window
  ;;   :bind
  ;;   (("C-x o" . ace-window)))
#+END_SRC

*** Expand Selection
It gradually expands the selection. Handy for Emacs Lisp or other programming languages.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package expand-region
    :defer t
    :bind ("C-=" . er/expand-region))
#+END_SRC
*** Picture Mode
Picture mode is a mode that let's you move freely without being limited/contained by line breaks.
You can quickly enter it with =C-c <ins>= and exit it with =C-c C-c=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key global-map (kbd "C-c <insert>") 'picture-mode) ;; C-c C-c to exit.
#+END_SRC
*** TODO Projectile

Projectile helps with navigating files, finding content, closing buffers and other stuff in a project.
It works for git, maven, ... or a folder with an empty ".projectile" file in it.

We install it and could modify the prefix from =C-c p= to =C-c C-p= (but we don't).

Useful keys include the following (note that we still have to add the prefix =C-c p= or =C-c C-p= to every key)
| Key | Action                                                         |
|-----+----------------------------------------------------------------|
| p   | List of Projects Buffer                                        |
| f   | Open file in Project                                           |
| a   | Toggle to file with other extension (.c -> .h)                 |
| S   | Save all project buffers                                       |
| s g | Grep (search projects file contents)                           |
| o   | multi-occur on project ?Like Grep, but only on opened buffers? |
| b   | List of open project buffers                                   |
| k   | Kill project buffers                                           |
| r   | Replace (interactive)                                          |
| T   | Show test files                                                |
| t   | Toggle to test file and implementation                         |
| c   | Run compile (can be configured for project)                    |
| P   | Run Tests (can be configured for project)                      |
| x e | Open eshell in the projects root folder                        |
| D   | open root folder                                               |
| i   | (Invalidate Cache)                                             |

Things to know:
- How to remove project from =<Prefix> p= :: =M-x projectile-remove-known-project=
- How to include/exclude files :: Write into the .projectile file lines like "-/log" "-*.class" "+/Source/Core". + gets evaluated before -
- How to configure test file name/compile command :: 

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package projectile
    :init (setq projectile-keymap-prefix (kbd "C-c p"))
    :config (projectile-global-mode))
#+END_SRC

We want to improve the projectile capabilities with helm.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package helm-projectile
    :after projectile
    :config
    (helm-projectile-on))
#+END_SRC
*** Updated movement commands
The old move to window line key was overridden, however I liked that command

#+BEGIN_SRC emacs-lisp :tangle yes
  (bind-key "M-g M-g" 'move-to-window-line)
#+END_SRC

** Autocomplete (with company)
Company is a great auto-completion tool.
It's adoption fast growing due to the fact that it's extensible and feature rich and the lack of tool-tip documentation is fixed with =company-quickhelp=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company
    :defer t
    :diminish company-mode
    :init (global-company-mode)
    :config
    (progn
      ;; Use Company for completion
      (bind-key [remap completion-at-point] #'company-complete company-mode-map)
      (bind-key [remap dabbrev-expand] #'company-complete company-mode-map) ; replace "stupid" expand/autocomplete
      (setq company-tooltip-align-annotations t)))            ;; Easy navigation to candidates with M-<n>

  (use-package company-quickhelp          ; Documentation popups for Company
    :if window-system
    :defer t
    :init
    (progn
      (eval-after-load 'company
        (add-hook 'global-company-mode-hook #'company-quickhelp-mode))
      (eval-after-load 'company
        '(define-key company-active-map (kbd "M-h") #'company-quickhelp-manual-begin))))
  ;;(company-quickhelp-mode 1)

  (use-package pos-tip ; better than the default popup
    :if window-system)
#+END_SRC

** Reading							    :clarify:
What is this good for?

This function is best used with line breaking like =visual-line-mode=
https://github.com/xahlee/xah_emacs_init/blob/master/xah_emacs_font.el From Xah Lee:
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun xah-toggle-margin-right ()
    "Toggle the right margin between `fill-column' or window width.
  This command is convenient when reading novel, documentation."
    (interactive)
    (if (eq (cdr (window-margins)) nil)
        (set-window-margins nil 0 (- (window-body-width) fill-column))
      (set-window-margins nil 0 0)))
#+END_SRC

** Editing
*** TODO Multiple Cursors
Multiple Cursors is a very nice tool to edit multiple things at one, where you would usually use macros.
You can cycle through the cursors with =C-v= and =M-v=. If you want to see the sections you're editing (but they are out of vision), press C-'.

If you copy stuff with many cursors and you want to insert it afterwards use =C-x r y=
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package multiple-cursors
    :bind
     (("C-c >" . mc/mark-all-like-this)
      ("C-c <" . mc/edit-lines)
      ("C->" . mc/mark-next-like-this)
      ("C-<" . mc/mark-previous-like-this)
      ("C-S-<mouse-1>" . mc/add-cursor-on-click)))
  ;;(use-package phi-search)
  ;;(use-package phi-search-mc :config (phi-search-mc/setup-keys))
  ;;(use-package mc-extras :config (define-key mc/keymap (kbd "C-. =") 'mc/compare-chars))
#+END_SRC

I need to get hold of this =phi-search= package.
Also I want the =ace-mc= package.

*** Snippets
Yasnippets is a mighty tool. With it you spend less time writing and more time coding.
It does that by expanding text like =sout= to =System.out.println=.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package yasnippet
    :diminish yas-minor-mode
    :init (yas-global-mode)
    :config
    (progn
      (setq yas-key-syntaxes '("w_" "w_." "^ ")) ;; by removing "w" we don't expand "s|ettengs" to "setq ettings"
      ;;(setq yas-installed-snippets-dir "~/.emacs.d/snippets")
      (setq yas-expand-only-for-last-commands nil)
      (yas-global-mode 1)
      ;;(add-to-list 'yas-prompt-functions 'shk-yas/helm-prompt) ;; a function from emacs wiki to use helm
      ))
  ;;        (global-set-key (kbd "C-c y") (lambda () (interactive)
  ;;                                         (yas/load-directory "~/elisp/snippets")))
#+END_SRC

*** Spell Checking and Grammar Checking and TTS

**** TODO Spelling						    :clarify:
Spell checking is necessary if you're working on official documents or letters.

The list of installed dictionaries can be obtained by typing =M-x ispell-change-dictionary RET SPC=.
We flyspell for the highlighting and hunspell for the correction.
We enable it for text-mode, and disable it for log-edit-mode and change-log-mode (derived from text-mode).
Also the prog-mode will have flycheck. But only for comments and quotations.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flyspell
    :diminish flyspell-mode
    :init
    (progn
      ;; we set it on in every text-mode, but log-mode
      (add-hook 'text-mode-hook 'flyspell-mode)
      (add-hook 'prog-mode-hook 'flyspell-prog-mode)
      (dolist (hook '(change-log-mode-hook log-edit-mode-hook))
        (add-hook hook (lambda () (flyspell-mode -1)))))
    :config
    (progn
      (setq ispell-program-name "hunspell") ;; Use hunspell to correct mistakes
      (setq flyspell-issue-message-flag nil) ;; printing messages for every word (when checking the entire buffer) causes an enormous slowdown.
    (eval-after-load "flyspell"
      '(progn
         (define-key flyspell-mode-map (kbd "C-.") nil)
         (define-key flyspell-mode-map (kbd "C-,") nil)
         (define-key flyspell-mode-map (kbd "C-;") nil)))
      )
    :bind
    (("<f12> s l" . ispell-change-dictionary)
     ("<f12> s C" . flyspell-buffer) ; check
     ("<f12> s c" . ispell) ; correct
     ))
#+END_SRC
What I need to check: how so shrink ispell dictionaries to those defined hunspell ones.

**** Grammar							 :firstSetup:
Grammar is also hard. That's why we use /LanguageTool/ to help us out.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package langtool
    :init
    (progn
      (setq langtool-java-classpath "/usr/share/languagetool:/usr/share/java/languagetool/*"))
    :config
    (setq langtool-mother-tongue "de"))

  (define-key global-map (kbd "<f12> g d") 'langtool-check-done) ; disable
  (define-key global-map (kbd "<f12> g l") 'langtool-switch-default-language)
  (define-key global-map (kbd "<f12> g C") 'langtool-check) ; enable
  (define-key global-map (kbd "<f12> g c") 'langtool-correct-buffer) ; correct
  (define-key global-map (kbd "<f12> g m") 'langtool-show-message-at-point) ; show message
#+END_SRC

**** TTS                                                         :firstSetup:
Text-to-Speech is great. But I don't want a simple implementation for TTS.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar my/tts-command "festival --tts &")
  (defun my/tts-read-region ()
    (interactive)
    "Read the selected region out loud. (Press C-g to abort.)"
    (shell-command-on-region (region-beginning) (region-end) my/tts-command))

  (defun my/tts-read-buffer ()
    (interactive)
    "Read the selected region out loud. (Press C-g to abort.)"
    (shell-command-on-region (point-min) (point-max) my/tts-command))

  (define-key global-map (kbd "<f12> r r") 'my/tts-read-region)
  (define-key global-map (kbd "<f12> r a") 'my/tts-read-buffer)
#+END_SRC

*** Aligning
Text or Programs that are properly aligned are more easy to read.
This greatly applies to programming languages.
E.g. mark the lines with the = sign and align by =.
#+BEGIN_SRC emacs-lisp :tangle yes
  (define-key global-map (kbd "C-M-<tab>") 'align-regexp)
#+END_SRC
*** Minibuffer editing - more space!
Sometimes you want to be able to do fancy things with the text that you're entering into the minibuffer.
Sometimes you just want to be able to read it, especially when it comes to lots of text.
This binds =M-M= (in a minibuffer) so that you can edit the contents of the minibuffer before submitting it.
I changed it from its default due to the binding =C-M-e= being occupied by my [[Smartparens]] binding.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package miniedit
    :commands minibuffer-edit
    :init
    (progn
      (miniedit-install)
      (define-key minibuffer-local-map "\M-M" 'miniedit)
      (define-key minibuffer-local-ns-map "\M-M" 'miniedit)
      (define-key minibuffer-local-completion-map "\M-M" 'miniedit)
      (define-key minibuffer-local-must-match-map "\M-M" 'miniedit)))
#+END_SRC

** Org
org-mode is a feature heavy major-mode capable of note taking, tracking time, table calculation, ...
I mainly use it as a note taking program and try to use it as a TODO list.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org
   :init
   (progn
     (setq org-todo-keywords '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")))
     (setq org-default-notes-file "~/Documents/org/Alltag.org")
     (setq org-capture-templates '(("t" "Todo     S-up/S-down and C-c . and " entry (file org-default-notes-file)            "* TODO %?\n  DEADLINE: %T SCHEDULED: %T\n")
                                   ("u" "Todo Uni S-up/S-down and C-c . and " entry (file "~/Documents/org/Universität.org") "* TODO %?\n  DEADLINE: %T SCHEDULED: %T\n")))
     (setq org-log-done 'time) ;; list CLOSED: <TIME> when finishing a task
     ;; agenda shows a week + day before today
     (setq org-agenda-start-day "-1d")
     (setq org-agenda-span 8)
     (setq org-agenda-start-on-weekday nil)
     ;; I dislike the "empty" time grid lines.
     (setq org-agenda-time-grid '((require-timed)
                                  (800 1000 1200 1400 1600 1800 2000)
                                  "......" "----------------"))
     ;; don't show me deadline-warnings if the task is not even scheduled yet. (has no influence on tasks that have no schedule entry). 1 Edge case is when a task schedules today (at a later time) but will not end today... bug or feature?
     (setq org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
     ;; show agenda in current window
     (setq org-agenda-window-setup 'current-window)
     ;; custom entry to list unfinished unscheduled task (without deadline)
     (setq org-agenda-custom-commands '(("u" "Unfinished unscheduled tasks" tags "-SCHEDULED={.+}&-DEADLINE={.+}/!"))))
   :bind
   (("C-c c" . org-capture)
    ("C-c o" . my/sync-org-todo)
    ("C-c a" . org-agenda)
    ("C-c b" . org-iswitchb)
    ("C-c l" . org-store-link)
    ("C-c L" . org-insert-link-global)
    ("C-c O" . org-open-at-point-global)))
#+END_SRC

=<s= blocks should be colored correctly depending on the mode.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq org-src-fontify-natively t)
#+END_SRC

https://emacs.stackexchange.com/a/31708
The custom function diary-list-day-of-month (set forth below) can be used to create a repeating org-mode task or to create a diary entry that will appear on the *Calendar* and/or in the *Org Agenda* buffer (if org-agenda-include-diary is t).
;;; ORG-MODE:  * My Task
;;;              SCHEDULED: <%%(diary-last-day-of-month date)>
;;; DIARY:  %%(diary-last-day-of-month date) Last Day of the Month
;;; See also:  (setq org-agenda-include-diary t)
;;; (diary-last-day-of-month '(2 28 2017))
(defun diary-last-day-of-month (date)
"Return `t` if DATE is the last day of the month."
  (let* ((day (calendar-extract-day date))
         (month (calendar-extract-month date))
         (year (calendar-extract-year date))
         (last-day-of-month
            (calendar-last-day-of-month month year)))
    (= day last-day-of-month)))

*** Addons

**** TODO Export org source highlighted			 :firstSetup:clarify:

I also use org mode for my sheets. The exported PDF should also have colored source blocks.
For this to work, we need to have =minted= installed. It's a non Emacs program found in the Arch Linux AUR.
#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'ox-latex)

  (add-to-list 'org-latex-packages-alist '("" "minted"))
  (setq org-latex-listings 'minted)

  (setq org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC

Can ox-latex be loaded with use-package?

**** Make org-mode pretty
While =org-mode= is mighty, it is sometimes kind of ugly.
Therefore we prettify it with =org-bullets=
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-bullets
    :init
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

**** Org-Drill
Org drill is used for Vocabulary Training or other stuff like that.
A org-drill file has the following structure

#+BEGIN_SRC emacs-lisp :tangle yes
;;  (use-package org-plus-contrib
    ;;:init (require 'org-drill)
;;    )
#+END_SRC

#+BEGIN_SRC org
  ,* Item                                   :drill:
  What is the capital city of Estonia?

  ,** The Answer
  Tallinn.

  ,* Item 2                              :drill:
  The capital city of Estonia is [Tallinn].

  Blah blubb [Antwort 1||Tipp 1]
  and [Antwort 2||Tipp 2].

  ,* Noun                                               :drill:
      :PROPERTIES:
      :DRILL_CARD_TYPE: twosided
      :END:

  Translate this word.

  ,** Spanish
  la mujer

  ,** English
  the woman

  ,** Example sentence
  # The section 'Example sentence' will never be shown until after the user presses a key, because it is not one of the first two 'sides' of the topic.
  ¿Quién fue esa mujer?
  Who was that woman?

  ,* Noun 2                                                              :drill:
      :PROPERTIES:
      :DRILL_CARD_TYPE: multisided
      :END:

  Translate.

  ,** Spanish
  la mesa

  ,** English
  the table

  ,** Picture
  Blah Blubb. Hier könnte auch ein Bild sein
#+END_SRC
More Info: http://orgmode.org/worg/org-contrib/org-drill.html#orgheadline10

** auctex
Auctex is the best latex editing suite I know.
Here we want to set Okular as our default PDF viewer.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package auctex
               :ensure t
               :mode ("\\.tex\\'" . latex-mode)
               :commands (latex-mode LaTeX-mode plain-tex-mode)
               :init
               (setq TeX-view-program-list (quote (("Okular" "okular --unique %o#src:%n%b"))))
               (setq TeX-view-program-selection
                     (quote
                      (((output-dvi style-pstricks)
                        "dvips and gv")
                       (output-dvi "xdvi")
                       (output-pdf "Okular")
                       (output-html "xdg-open")))))

  (use-package company-auctex
    :config (with-eval-after-load 'company (company-auctex-init))
    :commands company-mode)

#+END_SRC

** Calculate with region selection

From [[http://blog.jorgenschaefer.de/2012/03/emacs-snippets-calculation-helpers.html][Jorgen Schäfers]] web blog.

#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "C-c m") 'fc-calculate-region)
  (global-set-key (kbd "C-x r a") 'fc-add-rectangle)

  (defun fc-calculate-region (start end &optional prefix)
    "Evaluate the mathematical expression within the region, and
  replace it with its result.

  With a prefix arg, do not replace the region, but instead put the
  result into the kill ring."
    (interactive "r\nP")
    (let* ((expr (buffer-substring start end))
           (result (fc-bc-calculate-expression expr))
           (ends-with-newline (string-match "\n$" expr)))
      (if prefix
          (progn
            (kill-new result)
            (message "%s" result))
        (delete-region start end)
        (insert result)
        (when ends-with-newline
          (insert "\n")))))

  (defun fc-bc-calculate-expression (expr)
    "Evaluate `expr' as a mathematical expression, and return its result.

  This actually pipes `expr' through bc(1), replacing newlines with
  spaces first. If bc(1) encounters an error, an error is
  signalled."
    (with-temp-buffer
      (insert expr)
      (goto-char (point-min))
      (while (search-forward "\n" nil t)
        (replace-match " " nil t))
      (goto-char (point-max))
      (insert "\n")
      (call-process-region (point-min)
                            (point-max)
                           "bc" t t nil "-lq")
      (goto-char (point-min))
      (when (search-forward "error" nil t)
        (error "Bad expression"))
      (while (search-forward "\n" nil t)
        (replace-match "" nil t))
      (buffer-string)))

  (defun fc-add-rectangle (start end)
    "Add all the lines in the region-rectangle and put the result in the
  kill ring."
    (interactive "r")
    (let ((sum 0))
      (mapc (lambda (line)
              (string-match "-?[0-9.]+" line)
              (setq sum (+ sum (string-to-number (match-string 0 line)))))
            (extract-rectangle start end))
      (kill-new (number-to-string sum))
      (message "%s" sum)))
#+end_src

** TODO Programming
*** Folding
HideShow mode is preinstalled. However the current default keybindings are atrocious.
That's why we use the old Emacs 20 keybindings.
#+BEGIN_SRC emacs-lisp :tangle yes
  (load-library "hideshow")
  (global-set-key (kbd "C-c s") 'hs-show-block)
  (global-set-key (kbd "C-c S") 'hs-show-all)
  (global-set-key (kbd "C-c h") 'hs-hide-block)
  (global-set-key (kbd "C-c H") 'hs-hide-all)

  (add-hook 'c-mode-common-hook   'hs-minor-mode)
  (add-hook 'emacs-lisp-mode-hook 'hs-minor-mode)
  (add-hook 'java-mode-hook       'hs-minor-mode)
  (add-hook 'lisp-mode-hook       'hs-minor-mode)
  (add-hook 'perl-mode-hook       'hs-minor-mode)
  (add-hook 'sh-mode-hook         'hs-minor-mode)
#+END_SRC
*** Git								 :firstSetup:
Magit is one of the most beautiful git interface programs I've ever used.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
    :config
    (progn
      (when (equal system-type 'windows-nt)
        (setq magit-git-executable "c:/program files (x86)/git/bin/git.exe"))
      (setq magit-diff-options '("-b"))) ;; ignore whitespace
    :bind ("C-c g" . magit-status))
#+END_SRC
*** Flycheck
Syntax error checking and warnings for many languages.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flycheck
    :defer t
    :init
    (add-hook 'prog-mode-hook #'flycheck-mode)
    :config
    (progn
      (setq flycheck-check-syntax-automatically '(save mode-enabled)) ;; don't create files on every newline (SSD)
      (setq flycheck-standard-error-navigation nil))
    :commands flycheck-mode)
#+END_SRC
*** TODO Smartparens					 :improve_keybinding:
Smartparens is like Paredit a minor mode that helps with parenthesizes. However, unlike Paredit it is optimized for generally programming languages.
It supports a strict and non-strict mode, that either allows unbalanced parenthesizes or not.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package smartparens
    :diminish smartparens-mode
    :init
    (progn
      (require 'smartparens-config)
      (smartparens-global-mode 1)
      (show-smartparens-global-mode 1))
    :config
    (progn
      (setq smartparens-strict-mode t))
    :bind
    (("C-M-f" . sp-forward-sexp)
     ("C-M-b" . sp-backward-sexp)
     ;; anfang und ende "a" "e" (  | )  a(|  )  e(  |)
     ("C-M-a" . sp-beginning-of-sexp)
     ("C-M-e" . sp-end-of-sexp)
     ;; p soll in die nächste Klammer links rein oder raus. (leider erfüllt das up down nicht)
     ;;   bsp rein: (   (  ) |  )  (    (p)  )
     ;;   bsp raus: (   ( | )   )  (  p(  )  )
     ;; n soll in nächste klammer rechts rein oder raus. (leider erfüllt das up down nicht)
     ;;   bsp rein: (  | (  )   )  (  ( n )  )
     ;;   bsp raus: (   ( | )   )  (  (  )n  )
     ("M-s" . sp-splice-sexp) ;; entfernt klammer
     ("M-r" . sp-rewrap-sexp) ;; rename
     ("M-R" . sp-splice-sexp-killing-around) ;; cool da nur äußeres weg (weg| (da da) weg) => (da da)
     ("C-)" . sp-forward-slurp-sexp) ;; essen
     ("C-(" . sp-forward-barf-sexp) ;; kotzen
     ("C-}" . sp-backward-slurp-sexp) ;; essen
     ("C-{" . sp-backward-barf-sexp) ;; kotzen
     ("M-S" . sp-split-sexp) ;; richtig gut bei "Hallo | wie geht's" -> "Hallo " | " wie geht's"
     ("M-J" . sp-join-sexp) ;; umkehrung von M-S
     ("C-M-t" . sp-transpose-sexp) ;; besseres transpose
     ;;("C-M-<up>" . sp-transpose-hybrid-sexp) ;; not so fleshed out yet
     ))
#+END_SRC
*** TODO C++							 :firstSetup:

Created by the help of http://syamajala.github.io/c-ide.html.

=flycheck= however is configured to be run on every programming mode, that's why we don't configure it to be run on C/C++/Obj-C modes.
We only need to set the rtags specific stuff.

First we configure =rtags=, it has excellent source code navigation and some auto-complete. It comes with a company and flycheck plugin.

Some keys to remember (Prefix is =C-c r=)
| Key | Action                                                        |
|-----+---------------------------------------------------------------|
| .   | Jump to definitioin                                           |
| [   | Previous jump                                                 |
| ]   | Redo jump                                                     |
| </> | find-all-references-at-point                                  |
| R   | Rename                                                        |
| v   | List all reimplementations as well as definitions of function |
| h   | Print class hierarchy                                         |
| X   | Fixit at point (?is the irony version better?)                |
| S   | ??                                                            |

#+BEGIN_SRC emacs-lisp :tangle yes
;;  (use-package rtags
;;    :preface
;;    (defun my-flycheck-rtags-setup ()
;;      (flycheck-select-checker 'rtags)
;;      (setq-local flycheck-highlighting-mode nil) ;; RTags creates more accurate overlays.
;;      (setq-local flycheck-check-syntax-automatically nil))
;;    :config
;;    (progn
;;      (require 'flycheck-rtags)
;;      ;; c-mode-common-hook is also called by c++-mode
;;      (add-hook 'c-mode-common-hook #'my-flycheck-rtags-setup)
;;
;;      (require 'rtags-helm)
;;
;;      (require 'company-rtags)
;;      (setq rtags-completions-enabled t)
;;      (eval-after-load 'company
;;        '(add-to-list
;;          'company-backends 'company-rtags))
;;      (setq rtags-autostart-diagnostics t)
;;      (rtags-enable-standard-keybindings)
;;       ;; helm integration
;;      (setq rtags-use-helm t)))
#+END_SRC

After rtags we configure =irony=.
Irony is an excellent auto-complete for C and C++.

#+BEGIN_SRC emacs-lisp :tangle yes
;;  (use-package irony
;;    :preface
;;    (defun my-irony-mode-hook ()
;;      (define-key irony-mode-map [remap completion-at-point]
;;        'irony-completion-at-point-async)
;;      (define-key irony-mode-map [remap complete-symbol]
;;        'irony-completion-at-point-async))
;;    :init
;;    (progn
;;      (add-hook 'c++-mode-hook 'irony-mode)
;;      (add-hook 'c-mode-hook 'irony-mode)
;;      (add-hook 'objc-mode-hook 'irony-mode;;)

;;      (add-hook 'irony-mode-hook 'my-irony-mode-hook)
;;      (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options) ;; 
;;    
;;      (use-package company-irony
;;        :init (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
;;        :config
;;        (progn
;;          (setq company-backends (delete 'company-semantic company-backends))
;;          (use-package company-irony-c-headers
;;            :config
;;            (eval-after-load 'company
;;              '(add-to-list
;;                'company-backends '(company-irony-c-headers company-irony))))))
;;      (use-package flycheck-irony
;;        :config
;;        (eval-after-load 'flycheck
;;          '(add-hook 'flycheck-mode-hook #'flycheck-irony-setup)))))
#+END_SRC

Since =irony= and =rtags= require project information like compiler flags to work correctly, we use =cmake-ide=.
It automates cumbersome manual =cmake . -DCMAKE_EXPORT_COMPILE_COMMANDS=1= and =rc -J .= commands, and makes the use of =irony= and =rtags= easier.

#+BEGIN_SRC emacs-lisp :tangle yes
;;  (use-package cmake-ide
;;    :config (cmake-ide-setup))
#+END_SRC

cmake-ide sometimes fails when manual though. Therefore use the existing build directory place the following in your project root =.dir-locals.el= containing the following:
((nil . ((cmake-ide-build-dir . "buildDirectory")
         (eval . (progn
                   (require 'projectile)
                   ;; provide a fake "recent" compilation cmd
                   ;; which will be returned by the function
                   ;; `projectile-compilation-command`
                   (puthash (projectile-project-root)
                            "make -C buildDirectory"
                            projectile-compilation-cmd-map)
                   (puthash (projectile-project-root)
                            "build/projectExecutable"
                            projectile-run-cmd-map))))))



You can now build your project using =M-x cmake-ide-compile=.

*** Haskell							 :firstSetup:
The most beautiful language in the most beautiful editor.

We use the newly created [[ http://commercialhaskell.github.io/intero/][Intero]]. It requires =stack= to be installed on the system.
It features:
- autocompletion with company
- type checking with flycheck
- jump to definition
- "easy target switching" with =M-x intero-targets=
- and type selection with =C-c C-t=
#+BEGIN_SRC emacs-lisp :tangle yes
  ;;(use-package intero
  ;;  :init
  ;;  (add-hook 'haskell-mode-hook 'intero-mode))
  ;;
  ;;(use-package company-ghc
  ;;  :config (with-eval-after-load 'company (add-to-list 'company-backends 'company-ghc))
  ;;  :commands company-mode)
#+END_SRC

Intero automatically installs stuff.

*** Lua
Syntax highlighting for =.lua= files.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package lua-mode)
#+END_SRC
** Bug Workaround

*** Emacs Java							 :firstSetup:
Currently GNU java version is not working. So we set the variable to our favorite java executable.
This is required for [[Spell Checking][LanguageTool]].
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq langtool-java-bin "/bin/java")
#+END_SRC

* Custom Functions

** Smart upcase, downcase, capitalize
These functions let the normal upcase-word, downcase-word, capitalize-word operate on regions.
That way you can e.g. capitalize a subword by marking it. get[value] => getValue|

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun smart-upcase-region ()
    "Convert the region to upper case.  If no region is selected,
  it operates on the next word."
    (interactive)
    (if (use-region-p)
        (upcase-region (region-beginning) (region-end))
      (if 'current-prefix-arg
          (call-interactively 'upcase-word)
        (upcase-word 1))))

  (defun smart-downcase-region ()
    "Convert the region to down case.  If no region is selected,
  it operates on the next word."
    (interactive)
    (if (use-region-p)
        (downcase-region (region-beginning) (region-end))
      (if 'current-prefix-arg
          (call-interactively 'downcase-word)
        (downcase-word 1))))

  (defun smart-capitalize-region ()
    "Convert the region to down case.  If no region is selected,
  it operates on the next word."
    (interactive)
    (if (use-region-p)
        (capitalize-region (region-beginning) (region-end))
      (if 'current-prefix-arg
          (call-interactively 'capitalize-word)
        (capitalize-word 1))))

  (global-set-key (kbd "M-c") 'smart-capitalize-region)
  (global-set-key (kbd "M-l") 'smart-downcase-region)
  (global-set-key (kbd "M-u") 'smart-upcase-region)
#+END_SRC

** Calculate Timespan of following format (hh:mm-hh:mm) and sum timespans function
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/substract-timespan (beg end)
    "This function replaces marked timespans with the duration. e.g. 14:00-16:00 => 2:00, or 23:55 - 0:05 => 0:10. It also works on multiple times. e.g. 12:00-13:00 14:01 - 14:00 => 01:00 23:59"
    (interactive "*r")
    (setq the-text (buffer-substring beg end))

    (setq match-pos 0)
    (setq output-list nil)
    (cl-defstruct time-and-location time beg end) ;; stores calculated time and buffer pos of the old text position
  
    ;; match with text of following form "hh:mm - hh:mm"
    (while (setq match-pos (string-match "\\([0-9]\\{1,2\\}\\):\\([0-9]\\{1,2\\}\\)\s*-\s*\\([0-9]\\{1,2\\}\\):\\([0-9]\\{1,2\\}\\)" the-text match-pos))
      (setq match-extend (length (match-string 0 the-text)))
      (setq hour1 (string-to-number (match-string 1 the-text)))
      (setq hour2 (string-to-number (match-string 3 the-text)))
      (setq minute1 (string-to-number (match-string 2 the-text)))
      (setq minute2 (string-to-number (match-string 4 the-text)))

      ;; check for < 0 is required, since this means we haven't worked a full hour
      (if (< (- minute2 minute1) 0)
          (progn
            (setq negativeMinute 1) ;; carry over a substarction of 1 if no full hour was worked
            (setq minuteTemp (+ 60 (- minute2 minute1))))
        (progn
          (setq negativeMinute 0)
          (setq minuteTemp (- minute2 minute1))))

      ;; check for < 0 is required, since this means we passed into the next day
      (if (< (- hour2 hour1 negativeMinute) 0)
          (setq hourTemp (+ 24 (- hour2 hour1 negativeMinute))) ;; we passed into the next day
        (setq hourTemp (- hour2 hour1 negativeMinute)))
    
      (setq minute (% (+ minuteTemp (* 60 hourTemp)) 60))
      (setq hour (floor (/ (+ minuteTemp (* 60 hourTemp)) 60)))

      ;; store the output in a list (lifo/stack)
      (setq output (format "%02d:%02d" hour minute))
      (setq output-list (cons (make-time-and-location :time output :beg (+ beg match-pos) :end (+ beg match-pos match-extend)) output-list))

      (setq match-pos (+ match-pos match-extend)))

    (setq print-list nil)
    (while (setq loop (car output-list))
      (if (equal current-prefix-arg '(4)) ;; default C-u parameter
          ;; reverse list for readable output
          (progn
            (setq print-list (cons (time-and-location-time loop) print-list))
            (setq output-list (cdr output-list)))
        ;; replace textcontent
        (delete-region (time-and-location-beg loop) (time-and-location-end loop))
        (goto-char (time-and-location-beg loop))
        (insert (time-and-location-time loop))
        (setq output-list (cdr output-list))))

    ;; print if we used C-u
    (when print-list
      (message "%s" print-list)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/summate-time (beg end)
    "This function calculates the timespans together. 01:00 06:00 => 7:00, or 0:55 - 0:10 => 1:05."
    (interactive "*r")
    (setq the-text (buffer-substring beg end))

    (setq minute 0)
    (setq search-location 0)

    ;; match with text of following form "hh:mm"
    (while (setq search-location (string-match "\\([0-9]\\{1,2\\}\\):\\([0-9]\\{1,2\\}\\)" the-text search-location))
      (setq hourTemp (string-to-number (match-string 1 the-text)))
      (setq minuteTemp (string-to-number (match-string 2 the-text)))
      (setq minute (+ minute minuteTemp (* 60 hourTemp)))
    
      (setq match-extend (length (match-string 0 the-text)))
      (setq search-location (+ search-location match-extend)))

    (setq hour (floor (/ minute 60)))
    (setq minute (% minute 60))
    (setq output (format "%02d:%02d" hour minute))

    (if (equal current-prefix-arg '(4)) ;; default C-u parameter
        (progn
          (delete-region beg end)
          (insert output))
      (message output)))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/summate-timespans (beg end)
    "This function takes a list of timespans and calculates sum of the durations."
    (interactive "*r")
    (setq current-prefix-arg '(4)) ; C-u
    (setq output (my/substract-timespan beg end))
    (setq output-text (format "%s" output))
    (with-temp-buffer
      (goto-char (point-min))
      (insert output-text)
      (setq current-prefix-arg nil)
      (my/summate-time (point-min) (point-max))))
#+END_SRC

** TODO Working scroll lock for PageDown and PageUp
Scroll lock mode is the thing I want for =C-v= and =M-v= as an accidental =C-v= can be reverted and the point is on the same position.
However it is bugged when it comes to some visual modes like =org-bullet=.
That's why I made an implementation for page scrolling with lisp.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (defun my-scroll-down ()
  ;;   "This function scrolls down simular to C-v, however it also drags the point along.
  ;; ARG describes how many lines to move down"
  ;;   (interactive)
  ;;   (let ((lines-to-scroll (- (truncate (window-screen-lines)) next-screen-context-lines)) ;; next-screen-context-lines is an scroll offset used in the ordinary page scroll commands
  ;;         ;; emacs doesn't have a current window line command that's why we calculate it by calculating the difference to the top line (TODO handle hidden text e.g. folded org-text)
  ;;         (current-center (count-screen-lines
  ;;                          (save-excursion (move-to-window-line 0) (point))
  ;;                          (point))))
  ;;     (next-line lines-to-scroll auto-window-vscroll)
  ;;     (recenter current-center)))

  (defun my-scroll-down ()
    "This function scrolls down simular to C-v, however it also drags the point along.
    ARG describes how many lines to move down"
    (interactive)
    (let* ((lines-to-scroll (- (truncate (window-screen-lines)) next-screen-context-lines)) ;; next-screen-context-lines is an scroll offset used in the ordinary page scroll commands
          ;; emacs doesn't have a current window line command that's why we calculate it by calculating the difference to the top line (TODO handle hidden text e.g. folded org-text)
          (current-center (count-screen-lines
                           (save-excursion (move-to-window-line 0) (point))
                           (point)))
          (lines-to-scroll-pre-step (- lines-to-scroll current-center))
          (lines-to-scroll-post-step (- lines-to-scroll lines-to-scroll-pre-step)))
      (next-line lines-to-scroll-pre-step auto-window-vscroll)
      (recenter 0)
      (next-line lines-to-scroll-post-step auto-window-vscroll)))



  ;; (defun my-scroll-up ()
  ;;   ""
  ;;   (interactive)
  ;;   (let ((lines-to-scroll (- 0 (- (truncate (window-screen-lines)) next-screen-context-lines))) ;; next-screen-context-lines is an scroll offset used in the ordinary page scroll commands
  ;;         ;; emacs doesn't have a current window line command that's why we calculate it by calculating the difference to the top line (TODO handle hidden text e.g. folded org-text)
  ;;         (current-center (count-screen-lines
  ;;                          (save-excursion (move-to-window-line 0) (point))
  ;;                          (point))))
  ;;     (next-line lines-to-scroll auto-window-vscroll)
  ;;     (recenter current-center)))

  (defun my-scroll-up ()
    ""
    (interactive)
    (let* ((lines-to-scroll (- (truncate (window-screen-lines)) next-screen-context-lines)) ;; next-screen-context-lines is an scroll offset used in the ordinary page scroll commands
           ;; emacs doesn't have a current window line command that's why we calculate it by calculating the difference to the top line (TODO handle hidden text e.g. folded org-text)
           (current-center (count-screen-lines
                            (save-excursion (move-to-window-line 0) (point))
                            (point)))
           (lines-to-scroll-pre-step (- 0 current-center))
           (lines-to-scroll-post-step (- 0 (+ lines-to-scroll lines-to-scroll-pre-step))))
      (next-line lines-to-scroll-pre-step auto-window-vscroll)
      (recenter (count-screen-lines (save-excursion (move-to-window-line 0) (point))))
      (next-line lines-to-scroll-post-step auto-window-vscroll)))


  ;;(bind-key "C-v" 'my-scroll-down)
  ;;(bind-key "M-v" 'my-scroll-up)
#+END_SRC

** Region to leet
This function is converting latin text to leet speak.
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun region-to-leet (beg end)
    "This function is converting latin text to leet speak"
    (interactive "*r")
    (setq the-text (buffer-substring beg end))
    (setq the-leet
          (let ((tLen (+ 1 (- end beg))))
            (with-temp-buffer
              (insert the-text)
              (replace-regexp "[Aa]" "4" nil 1 tLen)
              (replace-regexp "[Cc]" "(" nil 1 tLen)
              (replace-regexp "[Ee]" "3" nil 1 tLen)
              (replace-regexp "[Gg]" "6" nil 1 tLen)
              (replace-regexp "[Hh]" "#" nil 1 tLen)
              (replace-regexp "[Ii]" "!" nil 1 tLen)
              (replace-regexp "[Ll]" "1" nil 1 tLen)
              (replace-regexp "[Oo]" "0" nil 1 tLen)
              (replace-regexp "[Ss]" "5" nil 1 tLen)
              (replace-regexp "[Tt]" "7" nil 1 tLen)
              (buffer-string)
              )))
    (delete-region beg end)
    (insert the-leet))
#+END_SRC

** TODO Hexcrypt						    :rethink:

/Vignere-Chiffre/ but with /xor/.

Currently the function requires =dash-functional= and =subr-x=.
So I need a rewrite.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dash-functional)
  (defun wrap-as-long (newlength list)
    "Stretches the list to the specified length, by REPEATING its content.
  However, it only does that, it it's not nil."
    (when (not (null list))
      (let* ((stretchAmount (- newlength (length list))))
        (if (<= stretchAmount 0)
            list
          (wrap-as-long newlength
                        (append list (-take stretchAmount list)) )
          )
        )
      )
    )

  (defun hexcrypt (textstart textend keyText)
    "XOR Crypt"
    (interactive "*r\nsEnter the key: ")
    (mapcar 'insert-string
            (let ( (text (string-to-list (buffer-substring-no-properties textstart textend)))
                   (key (string-to-list keyText)))
              (delete-region textstart textend)
              (mapcar (apply-partially 'format "0x%X ")
                      (-zip-with 'logxor text (wrap-as-long (length text) key)))
              )
            )
    )


  (require 'dash-functional)
  (require 'subr-x)
  (defun hexstring-to-number (text)
    "Takes a TEXT (e.g.: 0xFF 0xA 0xAFFE 0xDEADBEEF 0x1337) and converts it to a number list."
    (mapcar (-rpartial 'string-to-number 16)
            (remove ""
                    (mapcar 'string-trim (split-string text "[ \f\t\n\r\v]?0x"))
                    )
            )
    )

  (defun hexdecrypt (textstart textend keyText)
    "Takes two lists. TEXT and KEY and encypts those and formats them in the according way."
    (interactive "*r\nsEnter the key: ")
    (mapcar 'insert
            (let ((text (hexstring-to-number (buffer-substring-no-properties textstart textend)))
                  (key (string-to-list keyText)))
              (delete-region textstart textend)
              (-zip-with 'logxor text (wrap-as-long (length text) key))
              )
            )
    )
#+END_SRC

** Create Project Settings file
Many projects have different variables to set. Therefore we use environment variables to set the settings for each project accordingly.
Sadly I always forget the syntax and I always forget the filename. Therefore I created this method with the long name so I hopefully will find it again with helm.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/create-project-settings-file-dir-locals.el (arg)
    "Asks for a folder where to place the `.dir-locals.el' file and fills it with some commonly used settings"
    (interactive (list (read-file-name "Directory:")))
    (if (not (file-exists-p (concat arg "/.dir-locals.el")))
        (progn
          (find-file (concat arg "/.dir-locals.el"))
          (insert-file-contents "~/.emacs.d/dir-locals-template.el")
          (while (re-search-forward "<pwd>" nil t)
            (replace-match "")
            (pwd t)))
      (message "File already exists")))
#+END_SRC
** Revert some buffers
Sometimes I want so revert some buffers (e.g. when I sync files).
To make the process easier I use this function to revert only the files I synced
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/revert-files (files)
    "Refreshes all buffers of the file-list \"files\"."
    (interactive)
    (let ((files-absolute (mapcar 'file-truename files)))
      (dolist (buf (buffer-list))
        (with-current-buffer buf
          (when (and (buffer-file-name)                         ;; buffer opened a file
                     (member (buffer-file-name) files-absolute) ;; file is in the file-list
                     ;;(not (buffer-modified-p))                ;; buffer does not contain modified data
                     (file-exists-p (buffer-file-name)))        ;; file exists on disk
            (revert-buffer t t t)))))
    (message "Refreshed buffers."))
#+END_SRC

** Sync Org-Mode todo
#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/sync-org-todo ()
    "Launch syncing script"
    (interactive)
    (async-shell-command "~/Documents/org/0sync_with_android.sh"))
  ;; since I'm too stupid to find a callback-alternative for async-shell, I call my/revert-files on my org-files from the syncing script.
#+END_SRC
* Reminder
** Indention prog-mode
=C-M-\= is a key that re-indents regions in programming modes.
** Occur command in search
If you rather want to see all occurrences in a buffer than iterate over every occurance, press =M-s o= in the normal search (=C-s=).

Other useful keys are also available, however not so important (just look them up =C-s C-h m=).
** If you want to extend Emacs with Haskell
https://github.com/knupfer/haskell-emacs
** use-package
*** Where to place hooks?
http://emacs.stackexchange.com/questions/19695/use-package-defer-t-and-add-hook/19719

(use-package X
  :commands package-x-function
  :init
  (add-hook 'some-mode 'package-x-function))

Normally if the package wasn't deferred, you'd put the add-hook in the :config section, so that it wouldn't occur until the package was loaded.
In this case thanks to the autoload created by :commands, it makes sense to put it in the :init, otherwise there would never be a "trigger" run to autoload the package. – Jorge Israel Peña Jan 20 at 19:54

** TODO GUID gdb within emacs
** Debug/Search Emacs Variables
In case you want to search for a content of a emacs variable, you can use =M-x apropos-value=.
Now you can search for a expression and it lists all emacs variables that contain this value.

e.g. I want to add a text/filepath to a gdb file-open history (for a projectile project).
I launch =M-x gdb=. Enter a text like =aoirsnetaioresntoiarntifwentieanwf=.
Now I can search for =aoirsnetaioresntoiarntifwentieanwf= and find that it is located in =gud-gdb-history=.
Now I can modify it's content with a =.dir-locals.el= file.

* TODO Narrow Region and Spell Checking				    :clarify:
